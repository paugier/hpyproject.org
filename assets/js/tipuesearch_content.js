var tipuesearch = {
  "pages": [
    {
      "title": "#hpy IRC moves to Libera.Chat",
      "text": "Following the example of many other FOSS projects, the HPy team has\ndecided to move its official #hpy IRC channel from Freenode to\nLibera.Chat: irc.libera.chat/hpy\nThe core devs will no longer be present on the Freenode channel, so we recommend to\njoin the new channel as soon as possible.\nwikimedia.org has a\nnice guide on\nhow to setup your client to migrate from Freenode to Libera.Chat.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/hpy-irc-moves-to-libera-chat/"
    },
    {
      "title": "HPy @ Python Language Summit",
      "text": "Yesterday I had the privilege to give a talk about HPy\n (sildes) at the\n Python Language Summit 2021.\nThe organizers of the summit will soon publish a full report about the event,\nbut for the HPy-specific part, we got generally good feedback. Someone has a\nfew concerns that if CPython is to change the API, HPy might not be going far\nenough. Others said that Python shouldn't wait for the \"perfect\" API if HPy\ncan be the \"good\" one that helps it evolve.\nEveryone was open to have HPy-compatible wheels on PyPI, once the HPy\nUniversal ABI stays relatively stable. Many people suggested that we should\nreally write a PEP to propose HPy as a \"semi-official\" API for Python.\n\n\nAn interesting question was about which are the VM optimizations which are\ncompatible with the HPy API. The following is a non-exhaustive list of things\nwhich are known to work because they already used by PyPy and/or GraalPython:\n\nJIT compiler\nmoving/compacting GCs\nstorage strategies\nmaps (also known as \"hidden classes\")\n\nOne notable missing optimization from the list above is tagged\npointers. Currently there is no implementation which uses tagged pointers and\nsupports HPy. However, we don't think there is any fundamental design issue in\nHPy which would prevent it: if you turn tagged pointers into \"tagged handles\",\nthings should just work out of the box.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/hpy-python-language-summit/"
    },
    {
      "title": "HPy Status Update",
      "text": "HPy's first git commit was on Friday, 12 July 2019. Despite the crazy state\nof the world, HPy has come a long way\nsince then. This is a quick update to say where we are now and what's planned\nfor the immediate future.\n\n\nWhat can one do with HPy right now?\nOne can already port non-trivial Python extensions to the HPy API, but\nthere is also still a lot of work to do. Things one can do right now\nwith HPy include:\n\nInitialize an extension module\nCreate custom extension types\nCreate custom methods and functions\nInteract with many built-in types (including dictionaries, tuples,\n    lists, strings, bytes and longs)\nRaise and check exceptions\nParse arguments to C functions\nCall Python functions\nCompile an extension against either the \"universal\" or \"cpython\" ABIs (see below)\nLoad a single compiled \"universal\" extension into different Python implementations.\nPut a \"universal\" extension into debug mode at runtime (see below\n    for how this is possible without a performance penalty).\nCompile extensions for POSIX and Windows (MSVC).\n\nAn extension written using HPy may be compiled against either the \"cpython\" or\n\"universal\" ABI:\n\n\ncompiling against the \"cpython\" ABI produces an ordinary Python C extension.\n    The extension uses the HPy API only internally. From the point of view of\n    the Python implementation the compiled module is an ordinary C extension\n    that just happens to have been compiled using HPy. Note that as is the case\n    for ordinary C extensions, the modules produced target a specific\n    ABI tag.\n\n\ncompiling against the \"universal\" ABI produces an HPy C extension. This\n    extension does not use the Python C API directly at all and the ABI\n    is unique (up to platform and HPy version number). The same compiled module\n    may thus be loaded by multiple Python versions and implementations.\n    A Python implementation must know how to load such an extension and have\n    implemented the HPy universal ABI. Universal ABI implementations exist for\n    CPython, PyPy and GraalPython.\n\n\nDebug mode is implemented by replacing the HPy context with a debug mode\ncontext at runtime. The debug context wraps the original context and tracks\nall HPy API calls. Debug mode already supports finding handles that are\nleaked (i.e. not closed) and handles that are used after being closed.\nAdditional debug features will be fairly straightforward to add, like for example checking for NULL pointers or detecting whether the user is trying to call a function without holding the GIL.\nThe debug mode is written using HPy itself, so its implementation can be\nshared by different Python implementations that support HPy.\nWhat are the next steps?\nThe big picture is that we're working towards writing a Cython backend\nand porting core features of numpy to HPy. There is still some way to go\nbut the immediate next steps planned are:\n\n\nAdd support for storing long-lived references to other Python objects in\n    custom types, i.e. the equivalent of storing a PyObject * in\n    one of the fields with the struct of a custom type. HPy handles are only for\n    short-lived references, so we need a GC-friendly way to store long-lived\n    references.\n    See issue #9.\n\n\nImplement isolated module level state, to avoid using C static global\n    variables. This will be the HPy equivalent of\n    PEP 573 and\n    PEP 630.\n\n\nImplement multi-phase Python module initialization (HPy currently uses the\n    legacy module initialization).\n    See issue #183.\n\n\nUpdate the PyPy and GraalPython HPy implementations to support all the\n    latest HPy features.\n\n\nStart work on an HPy backend for Cython.\n\n\nContinuing work on a minimal port of numpy's array type to HPy.\n\n\nAsk the CPython core developers whether we can find a way to support\n    HPy universal extensions directly within in CPython (currently we write\n    a small .py file that knows how to load the universal extension, but\n    the presence of this stub file causes many small edge cases that are\n    annoying for HPy developers and users)\n\n\nIf you'd like to work on any of these with us, drop us a note in the\ncomments or mailing list or join us on IRC.\nHappy hacking,\nThe HPy Team.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/may-status-update/"
    },
    {
      "title": "Hello, HPy",
      "text": "Welcome to the shiny new HPy blog!\nHPy has been around for a while now. The initial discussion started during\nEuroPython 2019, in the good old times when we could still go to conferences\nand have real-life meetings. Since then, HPy progressed a lot from the\npoint of view of the actual code, but we have been a bit too silent\nw.r.t. communicating what we are doing to the external world and to the broader\nPython community. Hopefully, now that this blog is online we will do a better\njob at periodically communicating the status of HPy, so make sure to\nsubscribe to the RSS feed.\n\n\nWhat is HPy?\nQuoting the frontpage of our website:\n\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\nThe official Python/C API is\nspecific to the current implementation of CPython: it exposes many\ninternal details which makes it hard:\n\n\nto implement it for other Python implementations (e.g. PyPy, GraalPython,\n    Jython, IronPython, etc.)\n\n\nto experiment with new things inside CPython itself: e.g. using a GC\n    instead of refcounting, or to remove the GIL.\n\nto correctly check things like refcount handling: the external API gets mixed in with implementation details that should be hidden.\n\nOver the years, it has become evident that\nemulating the Python/C API in an efficient way is challenging,\nif not impossible. The main goal of HPy is expose a C API which is possible\nto implement in an efficient way on a number of very diverse Python\nimplementations.\nThere are several advantages to writing your C extension in HPy:\n\n\nit runs much faster on PyPy, and at native speed on CPython\n\n\nit is possible to compile a single binary which runs unmodified on all\n    supported Python implementations and versions\n\n\nit is simpler and more manageable than the Python/C API\n\n\nit provides an improved debugging experience: in \"debug mode\", HPy\n    actively checks for many common mistakes such as reference leaks and\n    invalid usage of objects after they have been deleted. It is possible to\n    turn the \"debug mode\" on at startup time, without needing to recompile\n    Python or the extension itself\n\n\nSee also the official docs for a more in-depth\noverview.\nShow me an example\nThis is a \"normal\" Python/C extension:\n2021/03/hello-hpy/hello_old.c  (Source)#include <Python.h>\n\nstatic PyObject* add(PyObject* self, PyObject* args) {\n    long a, b;\n    if (!PyArg_ParseTuple(args, \"ll\", &a, &b))\n        return NULL;\n    return PyLong_FromLong(a+b);\n}\n\nstatic PyMethodDef HelloMethods[] = {\n    {\"add\", (PyCFunction)add, METH_VARARGS, \"add two integers\"},\n    {NULL, NULL, 0, NULL}\n};\n\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"hello_old\",\n    \"hello example using the old Python/C API\",\n    -1,\n    HelloMethods,\n};\n\nPyMODINIT_FUNC\nPyInit_hello_old(void) {\n    return PyModule_Create(&moduledef);\n}\n\nWe can compile it with a simple setup.py:\nfrom setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n)\n\n$ python setup.py build_ext --inplace\n...\n$ python \n>>> import hello_old\n>>> hello_old.add(10, 20)\n30\n\nNow, let's start to uncover the HPy equivalent, piece by piece:\n#include <hpy.h>\n\nHPyDef_METH(add, \"add\", add_impl, HPyFunc_VARARGS,\n            .doc = \"add two integers\");\n\nstatic HPy add_impl(HPyContext ctx, HPy self, HPy *args, HPy_ssize_t nargs) {\n    long a, b;\n    if (!HPyArg_Parse(ctx, NULL, args, nargs, \"ll\", &a, &b))\n        return HPy_NULL;\n    return HPyLong_FromLong(ctx, a+b);\n}\n\nThere are a bunch of things which are different from the usual C-extension module:\n\n\nthe former PyObject * is now HPy, which we call \"a handle\". Handles are\n  similar to PyObject *, but are completely opaque: for more information,\n  see the\n  official docs.\n\n\nThere is an additional parameter, HPyContext ctx. One of the problems of\n  the old API is that often it implicitly relies on the existence of a\n  per-thread or per-subinterpreter local state. HPyContext makes this state explicit. This\n  makes the whole API more regular and makes it possible to develop new\n  interesting features such as the\n  Universal ABI\n  and the Debug mode.\n\n\nHPy introduces the concept of HPyDefs. HPyDef_METH is a macro which\n  generates the definition of an HPyDef static constant named add, which\n  represents the definition of a Python method implemented by the C function\n  add_impl. In this specific example HPyDef_METH contains more or less the\n  same informations as the old PyMethodDef, but HPyDef are more\n  general. For example, when defining custom types you can use things like\n  HPyDef_SLOT, HPyDef_GETSET, etc.\n\n\nNotice that we no longer need the cast to (PyCFunction). One of the\n  biggest advantages of HPyDef_METH is that since it's a macro, it can\n  automatically generate a forward declaration for add_impl, with the\n  correct signature. This means that if you use the wrong number and/or type\n  of parameters, you get a nice compile-time error instead of an obscure crash\n  at runtime.\n\n\nThe signature corresponding to HPyFunc_VARARGS is slighly different than\n  the old METH_VARARGS: we pass positional arguments as a C array instead of\n  a Python tuple. This means that it is possible to call the function without\n  having to allocate a Python tuple, and for example the PyPy implementation\n  of HPy takes advantage of that. This is very similar to CPython's\n  VectorCall protocol.\n\n\n\nNote\nIn this post, we are using a slightly old version of HPy. If you try with\na newer version you should use HPyContext *ctx instead of HPyContext ctx.\nSee also Issue #150\nand PR #182.\n\nLet's continue our tour of hello_new.c:\nstatic HPyDef *hello_defines[] = {\n    &add,\n    NULL\n};\n\nstatic HPyModuleDef moduledef = {\n    HPyModuleDef_HEAD_INIT,\n    .m_name = \"hello_new\",\n    .m_doc = \"hello example using the new HPy API\",\n    .m_size = -1,\n    .defines = hello_defines,\n};\n\nHPy_MODINIT(hello_new)\nstatic HPy init_hello_new_impl(HPyContext ctx) {\n    return HPyModule_Create(ctx, &moduledef);\n}\n\nThis is pretty similar to the old code. The biggest change is that instead of\ndeclaring an array of PyMethodDef, we create an array of HPyDef as\ndiscussed above.\nFinally, we need to modify setup.py. Compiling an HPy extension is as easy\nas adding setup_requires=['hpy.devel'] and use hpy_ext_modules:\n2021/03/hello-hpy/setup.py  (Source)from setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n    hpy_ext_modules = [\n        Extension('hello_new', ['hello_new.c']),\n    ],\n    setup_requires=['hpy.devel'],\n)\n\nCompiling HPy extensions\nIn this demo, we will show how to setup an environment to try HPy and compile\nextensions on both CPython and PyPy.\nAt the moment HPy is still in its early stages and the API is still subject to\nchange, so we have not done any official release yet. For the same reason, if\nyou want to use HPy on PyPy or GraalPython, you need to manually ensure to install\na version which is supported. This is just temporary, and this kind of things will\nbe sorted out automatically once we start to roll out official releases.\nSo, we need to install HPy from the github repo. Moreover, the HPy\nimplementations inside PyPy and GraalPython are lagging behind a little, so we will\ninstall a slightly old revision:\n\n\nHPy revision eb07982\n\n\nnightly build of the PyPy hpy branch: a2f7c80062e8 for linux64\n\n\nPyPy nighly builds: main page and\n  hpy branch\n\n\nGraalPython nightly build: Linux or macOS\n\n\nsource code of this example\n\n\nThe first step is to create a venv for CPython and install hpy:\n$ python3 -m venv tryhpy\n$ . tryhpy/bin/activate\n$ pip install wheel\n$ pip install git+git://github.com/hpyproject/hpy.git@eb07982\n\nTo install a nightly build of PyPy it is enough to unpack the tarball and run\n-m ensurepip. We can check what is the HPy version supported by PyPy by\ncalling hpy.universal.get_version():\n$ curl -O http://buildbot.pypy.org/nightly/hpy/pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ tar xf pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy -m ensurepip\n\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hpy.universal\n>>>> hpy.universal.get_version()\n('0.1.dev959+geb07982', 'eb07982')\n\nFor GraalPython, just unpack the tarball and create a venv:\n$ curl -LO https://github.com/graalvm/graalvm-ce-dev-builds/releases/download/21.1.0-dev-20210330_0726/graalpython-dev-linux-amd64.tar.gz\n$ tar xzf graalpython-dev-linux-amd64.tar.gz\n$ graalpython-21.1.0-dev-linux-amd64/bin/graalpython -m venv hpy-venv\n$ hpy-venv/bin/graalpython\n>>> import hpy.universal\n>>> hpy.universal.get_version()\n>>> ('0.1.dev950+g98f448a', '98f448a')\n\nNow that our enviroment is ready, we can compile and try our extensions:\n$ cd /path/to/example/\n$ . /path/to/tryhpy/bin/activate    # activate the venv\n$ python setup.py build_ext --inplace\n[...]\n\n$ ls -1 *.so\nhello_new.cpython-38-x86_64-linux-gnu.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>>\n\nIt worked! One important thing to note is the filename of hello_new:\n.cpython-38-x86_64-linux-gnu.so is the standard filename for CPython 3.8\nextension modules. This happens because by default hpy_ext_modules targets\nthe\nCPython ABI. As\nsuch, from the point of view of CPython hello_new is indistinguishable from\nhello_old. It also means that HPy is required only to compile it but not to\nimport it later. Finally, we expect the performance to be the very same as the\nextensions using the old API.\nHowever, we can also explicitly ask HPy to produce an \"universal binary\",\nwhich targets the\nHPy Universal ABI:\nas the name implies, universal binaries can be imported by CPython, but also\nby alternative implementations such as PyPy. We can build universal binaries\nby passing --hpy-abi=universal to setup.py:\n$ # clean the previous build\n$ rm -rf build/ *.so\n\n$ python setup.py --hpy-abi=universal build_ext --inplace\n$ ls -1 *.so\nhello_new.hpy.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\nNote the filename: hello_old is still a CPython-specific extension, but\nhello_new.hpy.so is an universal binary. Once compiled, you can import it as\nusual:\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n\n\nNote\nAt the moment of writing, because of\nIssue #191 if you try to\nprint the repr of hello_new, you see something like this (note the .py\nextension):\n>>> hello_new\n<module 'hello_new' from '/.../hello-hpy/hello_new.py'>\n\n\nNote that on its own, CPython does not know how to import .hpy.so\nfiles. The magic is done by the hello_new.py, which is automatically\ngenerated by setup.py:\n$ cat hello_new.py\n[...]\ndef __bootstrap__():\n    [...]\n    from hpy.universal import load_from_spec\n    ext_filepath = pkg_resources.resource_filename(__name__, 'hello_new.hpy.so')\n    m = load_from_spec(Spec('hello_new', ext_filepath))\n    [...]\n    sys.modules[__name__] = m\n\n__bootstrap__()\n\nFinally, we can try to import our shiny new universal binary on PyPy:\n$ /path/to/pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hello_new\n>>>> hello_new.add(10, 20)\n30\n>>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n>>>>\n\nSimilarly, it also just works on GraalPython:\n$ /path/to/graalpython/hpy-venv/bin/graalpython\n>>> import hello_new\n>>> hello_new.add(10, 20)\n30\n\nThat's all you need to get started with HPy. What we presented today is just\nthe basics, of course: in the next posts we will dig more into the technical\ndetails, and show more interesting features than just a hello world.\nStay tuned!\n(edited on 2021-03-31 to include GraalPython)",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/03/hello-hpy/"
    },
    {
      "title": "HPy - A better C API for Python",
      "text": "What is HPy?\nHPy provides a new API for extending Python in C.  In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\n\nWhat are the advantages of HPy?\n\nZero overhead on CPython: extensions written in HPy runs at the same\nspeed as \"normal\" extensions.\nMuch faster on alternative implementations such as PyPy, GraalPython.\nDebug Mode: in debug mode, you can easily identify common problems such\nas memory leaks, invalid lifetime of objects, invalid usage of APIs. Have\nyou ever forgot a Py_INCREF or Py_DECREF? The HPy debug mode will\ndetect these mistakes for you.\nUniversal binaries: extensions built for the HPy Universal ABI can be\nloaded unmodified on CPython, PyPy, GraalPython, etc.\nNicer API: the standard Python/C API shows its age. HPy is designed to\novercome some of its limitations, be more consistent, produce better quality\nextensions and to make it harder to introduce bugs.\n\n\n\nCurrent status\nHPy is still in an early stage of development and there is no official release\nyet. We hope to make our first alpha release in the next months but we don't\nhave any ETA.\nThe Python/C API is huge and at the moment only a small fraction of it is\navailable in HPy. We are experimenting by porting existing extensions to HPy\nand adding/designing new functionalities on a per-need basis.\nWe welcome your design input or adventurous alpha testing.\n\n\nHPy-compatible extensions\nThe extensions that we are experimenting with include:\n\nultrajson-hpy: this was the first real-world module to be ported to HPy. It is\na nice fit because it only exports functions (as opposed as custom types)\nand requires only a small number of API functions.\npiconumpy: as the name suggests, this is a minimal numpy-like module which\ndefines a custom type (similar to ndarray but with many fewer features of\ncourse).\nnumpy-hpy: one of our ambitious goals is to port numpy to HPy, and to use this\nexperience to better understand how to design the API. This is still at a\nvery early stage though.\n\n\n\nThis website and the logo are ugly\nWe know: we have expertise in Virtual Machines, Compilers, low-level\nprogramming, etc, but zero expertise in web development or graphic\ndesign. PRs are welcome ;)\n\n\nMore info\n\nOfficial docs\nHPy blog\nGithub repository\n#hpy IRC channel on the Libera.Chat server: irc.libera.chat/hpy\n\nNOTE: the official #hpy channel used to be on Freenode, but it is no\nlonger the case\n\n\nHPy is pronounced /h/ - pie (or using IPA notation: /e\u026at\u0283-pa\u026a/)\n\n\n\nRecent blog posts\n\n\n    \n            \n            2021-05-29 10:00\n            \u00a0\n            #hpy IRC moves to Libera.Chat\n            \n            \n            2021-05-12 10:00\n            \u00a0\n            HPy @ Python Language Summit\n            \n            \n            2021-05-07 10:00\n            \u00a0\n            HPy Status Update\n            \n            \n            2021-03-29 10:00\n            \u00a0\n            Hello, HPy",
      "tags": "",
      "url": "https://hpyproject.org/"
    }
  ]
};